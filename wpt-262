#!/usr/bin/env python

import os
import re
import string
import subprocess
import sys
import tempfile
import threading

from random import randint
from stat import *

TAB_SPACE = 2

OPTIONS = {
    "generate": [0, 1]      # Generate WPT tests. Accepts zero or one arguments.
}

def usage():
    print(
'''Usage: wpt-262 [--generate] <path-to-test262>
    --generate      Creates web-platform-test wrappers for test262. Generated tests are placed at js/test262/.
''')
    exit(1)

def parse_args():
    def is_opt(arg):
        return is_long_opt(arg) or is_short_opt(arg)
    def is_long_opt(arg):
        return arg.startswith('--')
    def is_short_opt(arg):
        return arg.startswith('-')
    def check_arguments():
        argv = sys.argv
        argc = len(argv)
        if not (argc == 2 or argc == 3):
            usage()
        return [argv, argc]
    def require(key, n):
        array = isinstance(OPTIONS[key], (int)) and [OPTIONS[key]] or OPTIONS[key]
        assert(isinstance(array, (list)))
        return n in array
    def parse_opt(argv, i):
        key = argv[i]
        if is_long_opt(key):
            key = key[2:]
        elif is_short_opt(key):
            key = key[1:]
        else:
            raise ValueError("Invalid option key: '%s'" % key)

        try:
            OPTIONS[key]
        except KeyError:
            print("Not recognized option: '%s'" % key)
            exit(1)

        # Last argument?
        if i == len(argv) - 1:
            if require(key, 0):
                return [key, True, i+1]
            else:
                raise ValueError("Option '%s' requires at least one value" % key)

        # Next argument is an option?
        val = argv[i+1]
        if is_opt(val):
            if require(key, 0):
                return [key, True, i+1]

        # Next argument is a value.
        if require(key, 1):
            return [key, val, i+2]
        else:
            raise ValueError("Option '%s' requires more than one value or less" % key)

    argv, argc = check_arguments()
    opts = {}; args = {}
    i = 1
    while i < argc:
        arg = argv[i]
        if is_opt(arg):
            key, value, i = parse_opt(argv, i)
            opts[key] = value
        else:
            args.append(arg)
            i = i+1
    return [opts, args]

###

# Parses a Test262 test. 
class Test262Parser(object):

    def __init__(self, text):
        match = re.search('---\*/', text)
        if match:
            self.header = text[:match.end(0)]
            self.body = text[match.end(0)+1:]
        else:
            self.header = ""
            self.body = text
        self.attrs = {}
        self.parse_header()

    def parse_header(self):
        if len(self.header) == 0:
            return
        value = []
        last_attr = None
        for line in self.header.split('\n'):
            # End of the attribute section?
            if re.search(r'---\*/', line):
                self.store_attribute(last_attr, "\n".join(value))
                break

            # Attribute? (attr: <text>)
            match = re.search(r'^\s*(\w+):', line)
            if match:
                attr = match.group(1)
                # Name of attribute changed?
                if attr != last_attr:
                    # Should store attribute?
                    if last_attr is not None:
                        self.store_attribute(last_attr, "".join(value))
                    match = re.search(': (.*)\n?', line)
                    if match:
                        value = [match.group(1)]
                    else:
                        value = []
                    last_attr = attr
            else:
                value.append(line)
        self.store_attribute(last_attr, "".join(value))

    def store_attribute(self, name, value):
        if name in ['includes', 'flags', 'features']:
            self.attrs[name] = self.parse_list(value)
        else:
            self.attrs[name] = value

    '''
    There are two ways of describing a list of properties:
       attr: [prop1, prop2, ..., propn]
       attr:
         - prop1
         - prop2
         - ...
         - propn
    '''
    def parse_list(self, text):
        match = re.search("\[", text)
        if match:
            return re.findall("[^\[, \]\n]+", text)
        else:
            return re.findall("[^- \n]+", text)

###

def trim(text):
    lines = text.split("\n")
    return "\n".join(lines[1:len(lines)-1])

# TODO: Put everything into one single template.
HEADER = trim('''
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>###TITLE###</title>
    <meta name="help" href="https://storage.spec.whatwg.org/#dom-storagemanager-persisted">
    <meta name="author" title="Mozilla" href="https://www.mozilla.org">

    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
    <script src="/resources/test262-harness.js"></script>

  </head>
  <body>
  </body>
  <script type="text/javascript">
###HEADER###
###ATTRS###
    function test262() {
''')
FOOTER = trim('''
    }
    window.addEventListener('load', function(e) {
###TESTS###
    });
  </script>
</html>
''')

ASYNC_TEST = trim('''
async_test(function(t) {
  ###TEST_CALL###(test262, attrs, t);
}, '###TITLE###');
''')

def run_in_iframe(title):
    output = ASYNC_TEST
    output = re.sub('###TITLE###', 'IFrame: ' + title, output)
    output = re.sub('###TEST_CALL###', 'run_in_iframe', output)
    return output

def run_in_iframe_strict(title):
    output = ASYNC_TEST
    output = re.sub('###TITLE###', 'IFrame (strict): ' + title, output)
    output = re.sub('###TEST_CALL###', 'run_in_iframe_strict', output)
    return output

def run_in_window(title):
    output = ASYNC_TEST
    output = re.sub('###TITLE###', 'Window: ' + title, output)
    output = re.sub('###TEST_CALL###', 'run_in_window', output)
    return output

def run_in_window_strict(title):
    output = ASYNC_TEST
    output = re.sub('###TITLE###', 'Window (strict): ' + title, output)
    output = re.sub('###TEST_CALL###', 'run_in_window_strict', output)
    return output

def run_in_worker(title):
    output = ASYNC_TEST
    output = re.sub('###TITLE###', 'Worker: ' + title, output)
    output = re.sub('###TEST_CALL###', 'run_in_worker', output)
    return output

def run_in_worker_strict(title):
    output = ASYNC_TEST
    output = re.sub('###TITLE###', 'Worker (strict): ' + title, output)
    output = re.sub('###TEST_CALL###', 'run_in_worker_strict', output)
    return output

def run_in_shared_worker(title):
    output = ASYNC_TEST
    output = re.sub('###TITLE###', 'SharedWorker: ' + title, output)
    output = re.sub('###TEST_CALL###', 'run_in_shared_worker', output)
    return output

def run_in_shared_worker_strict(title):
    output = ASYNC_TEST
    output = re.sub('###TITLE###', 'SharedWorker (strict): ' + title, output)
    output = re.sub('###TEST_CALL###', 'run_in_shared_worker_strict', output)
    return output

def stringify(list):
    if list == None or len(list) == 0:
        return '[]'
    ret = []
    for i in range(0, len(list)):
        elem = "'" + str(list[i]) + "'"
        ret.append(elem)
    return '[%s]' % ",".join(ret)

def tojson(d, opts):
    ret = []
    exclude = opts['exclude'] or []
    def append(string):
        ret.append(string)
    def flush():
        return "\n".join(ret)
    def quote(v):
        if isinstance(v, str):
            if len(v) == 0:
                return "''"
            first, last = [v[0], v[len(v)-1]]
            if first == "'" and last == "'":
                return v
            if first == '"' and last == '"':
                return v
        return "'%s'" % str(v)
    def escape(v):
        return re.sub(r"'", r"\'", v)
    append('{')
    for k, v in d.iteritems():
        if k in exclude:
            continue
        if isinstance(v, list):
            append("\t{key}: {value},".format(key=k, value=stringify(v)))
        else:
            append("\t{key}: {value},".format(key=k, value=quote(escape(v))))
    append('}')
    return flush()

def indent(num_tabs, content):
    def dup(char, times):
        ret = []
        for i in range(0, times):
            ret.append(char)
        return "".join(ret)
    ret = []
    space = dup(" ", num_tabs * TAB_SPACE)
    for line in content.split("\n"):
        ret.append(space + line)
    return "\n".join(ret)

class WPTestBuilder(object):

    def __init__(self, path):
        self.path = path

    def generate(self):
        path = self.path
        mode = os.stat(path)[ST_MODE]
        if S_ISDIR(mode):
            print "Generating WPT wrapper for test262"
            for each in self.listall(path, {'ext': 'js', 'skip_hidden': True}):
                self.generate_single_wpt(each)
            print "Output: js/%s" % path
        elif S_ISREG(mode):
            print "Generating WPT wrapper for {0}".format(path)
            dst = self.generate_single_wpt(path)
            print "Output: %s" % dst
        else:
            print "Skipping %s" % path

    def generate_single_wpt(self, path):
        output = self.ensure_destination_path(path)
        return self.savefile(output, self.build(output, self.readfile(path)))

    def savefile(self, output, content):
        with open(output, 'wt') as fd:
            fd.write(content)
            return fd.name

    def build(self, title, content):
        test262 = Test262Parser(content)
        def header():
            opts = { 'exclude': ['description', 'info', 'esid', 'es6id'] }
            ret = HEADER
            ret = re.sub('###TITLE###', title, ret)
            ret = ret.replace('###ATTRS###', indent(2, "let attrs = %s;" % tojson(test262.attrs, opts)))
            ret = ret.replace('###HEADER###', indent(2, test262.header))
            return ret
        def body():
            def escape(text):
                text = re.sub(r'\\', r'\\\\', text)
                text = re.sub(r'"', r'\"', text)
                return text
            def quote(line):
                return "\"" + line + "\\n\""
            def format(text):
                output = []
                lines = text.split("\n");
                for line in text.split("\n"):
                    if len(line) > 0:
                        output.append(quote(line))
                return " + \n".join(output)
            return indent(4, "return \"\" +\n%s;" % format(escape(test262.body)))
        def footer():
            # By default tests are run in strict and non-strict modes,
            # unless flags says otherwise.
            ret = []
            flags = 'flags' in test262.attrs and test262.attrs['flags'] or []
            if 'onlyStrict' in flags:
                ret.append(run_in_iframe_strict(title))
                ret.append(run_in_window_strict(title))
                ret.append(run_in_worker_strict(title))
                ret.append(run_in_shared_worker_strict(title))
            elif 'noStrict' in flags:
                ret.append(run_in_iframe(title))
                ret.append(run_in_window(title))
                ret.append(run_in_worker(title))
                ret.append(run_in_shared_worker(title))
            else:
                ret.append(run_in_iframe_strict(title))
                ret.append(run_in_iframe(title))
                ret.append(run_in_window_strict(title))
                ret.append(run_in_window(title))
                ret.append(run_in_worker_strict(title))
                ret.append(run_in_worker(title))
                ret.append(run_in_shared_worker_strict(title))
                ret.append(run_in_shared_worker(title))
            return FOOTER.replace("###TESTS###", indent(3, "\n".join(ret)))
        ret = []
        ret.append(header())
        ret.append(body())
        ret.append(footer())
        return "\n".join(ret)

    def readfile(self, path):
        with open(path) as fd:
            content = fd.read()
            # Remove carriage return if any.
            return re.sub("\x0D", "", content)

    def ensure_destination_path(self, path):
        dirname = subprocess.check_output(("dirname {0}".format(path)).split())
        dirname = re.sub('\n', '', dirname)
        process = subprocess.Popen(("mkdir -p js/{0}".format(dirname)).split())
        process.wait() 
        return 'js/%s' % (re.sub('.js$', '.html', path))

    def listall(self, root, opts):
        opts = opts or {}
        result = []
        def ls(path):
            return os.listdir(path)
        def lsr(path):
            if not os.path.isdir(path):
                if not opts['ext'] or path.endswith(opts.ext):
                    result.append(path)
            for f in ls(path):
                if opts['skip_hidden'] and f.startswith('.'):
                    continue
                filename = os.path.join(path, f)
                if os.path.isdir(filename):
                    lsr(filename)
                else:
                    result.append(filename)
        lsr(root)
        return result

def main():
    opts, args = parse_args()
    if opts['generate']:
        val = opts['generate']
        path = isinstance(val, (bool)) and 'test262/test' or val
        WPTestBuilder(path).generate()

if __name__ == "__main__":
    main()
